import{createQuickAccess as e,dashesToCamelCase as t,camelCaseToDashes as r}from"./tools.js";const s=Symbol("properties");function n(t){t.$||(t.$=e(t.shadowRoot,"id"),t.$$=e=>t.shadowRoot.querySelector(e),t.$$$=e=>Array.from(t.shadowRoot.querySelectorAll(e)))}const o="web-component-base-element";export class webComponentBaseClass extends HTMLElement{static get is(){return o}static get template(){return""}static get properties(){return{}}static get observedAttributes(){return this.properties?Object.keys(this.properties).map(e=>r(e)):[]}constructor(){super(),this[s]={},this.$=null,this.$$=()=>null,this.$$$=()=>[],console.assert(this.constructor.is!==o,'Error, make sure that the web component implements: static get is() { return "name-of-your-web-component"; }'),function(e,t){const r=document.createElement("div");r.innerHTML=t.trim();let s=r.firstChild;s instanceof HTMLTemplateElement||((s=document.createElement("template")).innerHTML=r.innerHTML),e.attachShadow({mode:"open"}).appendChild(s.content.cloneNode(!0))}(this,this.constructor.template),this.eventHandlers=[]}connectedCallback(){!function(e,t){if(n(e),t){const n={};Object.keys(t).forEach(o=>{const a=t[o],i=r(o);n[o]=e[o],Object.defineProperty(e,o,{get:()=>e[s][o],set(t){const r=e[s][o];let n=e=>e.toString();switch(a.type){case Array:e[s][o]="string"==typeof t?JSON.parse(t):Array.isArray(t)?t:[],n=e=>JSON.stringify(e);break;case Boolean:e[s][o]=t&&"false"!==t,n=()=>"";break;case Number:e[s][o]=(void 0===t?0:Number(t))||0;break;case Object:e[s][o]="string"==typeof t?JSON.parse(t):"object"==typeof t?t:{},n=e=>JSON.stringify(e);break;case String:e[s][o]=(null==t?"":String(t))||""}a.observer&&("function"==typeof a.observer?r!==e[s][o]&&a.observer(e,e[s][o],r):e[a.observer]?r!==e[s][o]&&e[a.observer](e[s][o],r):console.warn(`The observer with the name: '${a.observer}' was not found inside the class for web component ${e.constructor.is}. Make sure that you added a public function with the name '${a.observer}' to the class.`)),a.reflectToAttribute&&(e[s][o]?e.setAttribute(i,n(e[s][o])):e.removeAttribute(i))}})}),Object.keys(t).forEach(s=>{const o=t[s],a=r(s);let i,c=n[s]||null;if(c)switch(o.type){case Array:Array.isArray(c)?e[s]=c:c=null;break;case Boolean:"boolean"==typeof c?e[s]=c:c=null;break;case Number:"number"==typeof c?e[s]=c:c=null;break;case Object:"object"==typeof c?e[s]=c:c=null;break;case String:"string"==typeof c?e[s]=c:c=null}if(e.hasAttribute(a)&&(i=e.getAttribute(a)),o.reflectToAttribute||void 0===e[s])if(void 0!==i)switch(o.type){case Array:e[s]=JSON.parse(i);break;case Boolean:e[s]="false"!==i;break;case Number:e[s]=Number(i);break;case Object:e[s]=JSON.parse(i);break;case String:e[s]=String(i)}else switch(o.type){case Array:e[s]=o.value||[];break;case Boolean:e[s]=o.value||!1;break;case Number:e[s]=o.value||0;break;case Object:e[s]=o.value||{};break;case String:e[s]=o.value||""}})}}(this,this.constructor.properties),this.attached&&this.attached(),this.onAttached&&this.onAttached(this),Object.defineProperty(this,"onAttached",{get(){},set(e){e(this)}})}disconnectedCallback(){this.detached&&this.detached(),this.onDetached&&this.onDetached(this),this.eventHandlers.forEach(e=>{e.element.removeEventListener(e.event,e.handler)})}attributeChangedCallback(e,r,s){const o=t(e);n(this),this.constructor.properties[o]&&this.constructor.properties[o].type===Boolean&&(r=!!(""===r||r&&"false"!==r),s=!!(""===s||s&&"false"!==s)),r!==s&&(this[o]=s)}addAutoEventListener(e,t,r){this.eventHandlers.find(s=>s.element===e&&s.event===t&&s.handler===r)||(this.eventHandlers.push({element:e,event:t,handler:r}),e.addEventListener(t,r))}removeAutoEventListener(e,t,r){const s=this.eventHandlers.findIndex(s=>s.element===e&&s.event===t&&s.handler===r);-1!==s&&(this.eventHandlers.splice(s,1),e.removeEventListener(t,r))}refreshQuickAccess(){this.$=e(this.shadowRoot,"id")}}
//# sourceMappingURL=webComponentBaseClass.js.map